# .github/workflows/build-and-push-on-vm.yml

name: Build and Push AI Backend on Build VM and Redeploy RunPod

on:
  push:
    branches:
      - main
      - dev
      - ml_dev

jobs:
  build-push-redeploy:
    name: Build, Push, and Redeploy on RunPod
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Determine Environment
        id: get_env
        run: |
          if [ "${{ github.ref_name }}" == "main" ]; then
            echo "Production environment detected from 'main' branch."
            echo "env_prefix=prod" >> $GITHUB_OUTPUT
            echo "env_file=.env.prod" >> $GITHUB_OUTPUT
            echo "docker_services=prod_backend prod_bot" >> $GITHUB_OUTPUT
            echo "docker_image_tag=roma3213/maryrose-app:prod" >> $GITHUB_OUTPUT
            echo "docker_image_repo=roma3213/maryrose-app" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref_name }}" == "ml_dev" ]; then
            echo "ML development environment detected from 'ml_dev' branch."
            echo "env_prefix=ml-dev" >> $GITHUB_OUTPUT
            echo "env_file=.env.dev" >> $GITHUB_OUTPUT
            echo "docker_services=dev_backend dev_bot" >> $GITHUB_OUTPUT
            echo "docker_image_tag=roma3213/maryrose-app:ml-dev" >> $GITHUB_OUTPUT
            echo "docker_image_repo=roma3213/maryrose-app" >> $GITHUB_OUTPUT
          else
            echo "Development environment detected from '${{ github.ref_name }}' branch."
            echo "env_prefix=dev" >> $GITHUB_OUTPUT
            echo "env_file=.env.dev" >> $GITHUB_OUTPUT
            echo "docker_services=dev_backend dev_bot" >> $GITHUB_OUTPUT
            echo "docker_image_tag=roma3213/maryrose-app:dev" >> $GITHUB_OUTPUT
            echo "docker_image_repo=roma3213/maryrose-app" >> $GITHUB_OUTPUT
          fi

      - name: Build and Push Docker Image on Main VM
        if: success()
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.MAIN_SERVICE_SSH_HOST }}
          username: ${{ secrets.MAIN_SERVICE_SSH_USER }}
          key: ${{ secrets.MAIN_SERVICE_SSH_PRIVATE_KEY }}
          script: |
            set -e

            echo "--- Starting build on Main VM for ${{ steps.get_env.outputs.env_prefix }} environment ---"
            cd MaryRose
            git fetch origin
            echo "Pulling latest code from ${{ github.ref_name }} branch..."
            git checkout ${{ github.ref_name }}
            git pull origin ${{ github.ref_name }}

            echo "Logging into Docker Hub..."
            echo ${{ secrets.DOCKER_PASSWORD }} | sudo docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin

            echo "Building Docker image: ${{ steps.get_env.outputs.docker_image_tag }}..."
            sudo docker build -t ${{ steps.get_env.outputs.docker_image_tag }} .

            echo "Pushing Docker image: ${{ steps.get_env.outputs.docker_image_tag }} to Docker Hub..."
            sudo docker push ${{ steps.get_env.outputs.docker_image_tag }}

            # Using dynamic anchor name based on environment
            ANCHOR_NAME="anchor-for-maryrose-app-${{ steps.get_env.outputs.env_prefix }}"
            sudo docker rm $ANCHOR_NAME || true
            sudo docker create --name=$ANCHOR_NAME --label "do-not-prune=true" ${{ steps.get_env.outputs.docker_image_tag }}

            sudo docker image prune -a -f

            echo "--- Docker image build and push completed successfully ---"

      - name: Cleanup old untagged images on Docker Hub via API
        if: success()
        run: |
          IMAGE_REPO=${{ steps.get_env.outputs.docker_image_repo }}
          USERNAME=${{ secrets.DOCKER_USERNAME }}
          PASSWORD=${{ secrets.DOCKER_PASSWORD }}

          # --- ИСПРАВЛЕНИЕ: ИЗВЛЕКАЕМ ТЕГ ВНУТРИ run: БЛОКА ---
          DOCKER_IMAGE_TAG=$(echo "${{ steps.get_env.outputs.docker_image_tag }}" | cut -d: -f2)

          TOKEN=$(curl -s -H "Content-Type: application/json" -X POST -d '{"username": "'$USERNAME'", "password": "'$PASSWORD'"}' https://hub.docker.com/v2/users/login/ | jq -r .token)

          if [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; then echo "Error: Failed to get Docker Hub token."; exit 1; fi

          DIGESTS=$(curl -s -H "Authorization: JWT $TOKEN" "https://hub.docker.com/v2/repositories/$IMAGE_REPO/tags/?page_size=100" | jq -r '.results[].images[] | select(.status == "active") | .digest')

          # Используем локальную переменную DOCKER_IMAGE_TAG
          CURRENT_DIGEST=$(curl -s -H "Authorization: JWT $TOKEN" "https://hub.docker.com/v2/repositories/$IMAGE_REPO/tags/$DOCKER_IMAGE_TAG/" | jq -r '.images[] | select(.status == "active") | .digest')

          echo "Current digest for tag '$DOCKER_IMAGE_TAG' is $CURRENT_DIGEST"

          for digest in $DIGESTS; do
            if [ "$digest" != "$CURRENT_DIGEST" ]; then
              echo "Deleting old, untagged image with digest: $digest"
              # curl -s -X DELETE -H "Authorization: JWT $TOKEN" "https://hub.docker.com/v2/repositories/$IMAGE_REPO/manifests/$digest"
              echo "Dry Run: Would have deleted digest $digest"
            else
              echo "Keeping current image with digest: $digest"
            fi
          done

      - name: Install RunPodCTL and jq for RunPod operations
        run: |
          curl -L https://github.com/runpod/runpodctl/releases/download/v1.14.4/runpodctl-linux-amd64 -o runpodctl

          # Check if the download was successful (file size > 0)
          if [ ! -s runpodctl ]; then
            echo "Fatal: Failed to download runpodctl binary."
            exit 1
          fi

          sudo install -m 0755 runpodctl /usr/local/bin/runpodctl

          # Verify that the installation was successful
          echo "runpodctl version:"
          runpodctl --version

          sudo apt-get update && sudo apt-get install -y jq

      - name: Get Existing Pod ID for Redeployment
        id: get_existing_pod
        env:
          RUNPOD_API_KEY: ${{ secrets.RUNPOD_API_KEY }}
        run: |
          ENV_PREFIX="${{ steps.get_env.outputs.env_prefix }}"
          echo "Searching for existing pod with prefix '${ENV_PREFIX}' to redeploy..."
          POD_ID=$(runpodctl get pod | grep "${ENV_PREFIX}-ai-backend" | head -n 1 | awk '{print $1}')

          if [ -z "$POD_ID" ]; then
            echo "Error: No existing pod found with prefix '${ENV_PREFIX}'. Aborting."
            exit 1
          fi

          echo "Found existing pod with ID: $POD_ID"
          echo "pod_id=$POD_ID" >> $GITHUB_OUTPUT

      - name: Stop Existing Pod
        id: stop_pod
        env:
          RUNPOD_API_KEY: ${{ secrets.RUNPOD_API_KEY }}
        run: |
          POD_ID=${{ steps.get_existing_pod.outputs.pod_id }}
          echo "Stopping pod $POD_ID..."
          runpodctl stop pod $POD_ID
          echo "Pod stop command sent. Waiting for it to enter 'EXITED' state..."

          for i in {1..10}; do
            CURRENT_STATUS=$(runpodctl get pod $POD_ID | tail -n 1 | awk '{print $NF}')
            
            if [ "$CURRENT_STATUS" == "EXITED" ]; then
              echo "Pod $POD_ID is now EXITED."
              exit 0
            fi
            
            echo "Waiting for pod $POD_ID to stop. Current status: $CURRENT_STATUS..."
            sleep 10
          done
          echo "Fatal: Pod $POD_ID did not stop in time."
          exit 1

      - name: Start Existing Pod
        id: start_pod
        env:
          RUNPOD_API_KEY: ${{ secrets.RUNPOD_API_KEY }}
        run: |
          POD_ID=${{ steps.get_existing_pod.outputs.pod_id }}
          echo "Starting pod $POD_ID..."
          runpodctl start pod $POD_ID
          echo "Pod start command sent."

      - name: Wait for pod to become healthy
        id: wait_for_health
        run: |
          POD_ID=${{ steps.get_existing_pod.outputs.pod_id }}
          HEALTH_URL="https://${POD_ID}-8001.proxy.runpod.net/health"

          echo "Waiting for application to become healthy at: $HEALTH_URL"

          for i in {1..20}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_URL)
            
            if [ "$HTTP_CODE" -eq 200 ]; then
              echo "Health check successful! Application is ready."
              AI_URL="https://$(echo $POD_ID)-8001.proxy.runpod.net"
              WEBSOCKET_URL=$(echo "$AI_URL" | sed 's|https|wss|')/ws/listen/
              echo "AI_BACKEND_URL=$AI_URL" >> $GITHUB_OUTPUT
              echo "AI_WEBSOCKET_URL=$WEBSOCKET_URL" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            echo "Health check failed with status code $HTTP_CODE. Waiting 15 seconds..."
            sleep 15
          done

          echo "Fatal: Application did not become healthy in time."
          exit 1

      - name: Update main VM with new URLs
        if: success()
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.MAIN_SERVICE_SSH_HOST }}
          username: ${{ secrets.MAIN_SERVICE_SSH_USER }}
          key: ${{ secrets.MAIN_SERVICE_SSH_PRIVATE_KEY }}
          script: |
            set -e
            NEW_AI_URL="${{ steps.wait_for_health.outputs.AI_BACKEND_URL }}"
            NEW_WS_URL="${{ steps.wait_for_health.outputs.AI_WEBSOCKET_URL }}"
            ENV_FILE="${{ steps.get_env.outputs.env_file }}"
            DOCKER_SERVICES="${{ steps.get_env.outputs.docker_services }}"
            DEPLOY_DIR="/home/turikroma15/mary-deployment"

            echo "New AI Backend URL for ${{ steps.get_env.outputs.env_prefix }}: $NEW_AI_URL"
            echo "Updating $ENV_FILE file on the main VM at $DEPLOY_DIR/$ENV_FILE..."

            sed -i "s|^AI_BACKEND_URL=.*|AI_BACKEND_URL=$NEW_AI_URL|" "$DEPLOY_DIR/$ENV_FILE"
            sed -i "s|^AI_WEBSOCKET_URL=.*|AI_WEBSOCKET_URL=$NEW_WS_URL|" "$DEPLOY_DIR/$ENV_FILE"

            echo "$ENV_FILE updated successfully."

            cd $DEPLOY_DIR
            echo "Restarting $DOCKER_SERVICES services..."
            sudo docker compose --env-file "$ENV_FILE" up -d $DOCKER_SERVICES

            echo "Services for ${{ steps.get_env.outputs.env_prefix }} have been restarted successfully."
